\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{hyperref}
\usepackage{rotating}

\title{Ideas for\\An Optimizing Compiler\\for Sound Analysis and Synthesis}
\author{Samuel Mimram}

\hypersetup{
  pdftitle={\csname @title\endcsname},
  pdfauthor={\csname @author\endcsname},
  unicode=true,
  colorlinks=true,
  linkcolor=black,
  citecolor=black,
  urlcolor=black
}

\begin{document}
\maketitle

\section{What we want}
\subsection{What we should be able to do}
\begin{itemize}
\item We want to be able to manipulate streams of data: audio (streams of
  samples), video (streams of images), etc.
\item We should distinguish between two kind of things that we manipulate:
  \emph{values} which are always available in a stream (samples in audio data)
  and \emph{events} which are punctual data (metadata, notes, etc.)
\item We should be able to trigger a event of type unit when a data changes
  (typically when the audio data gets louder than a certain value): we need a
  function $bool \to unit\ event$.
\item It would be very nice to have a good typing of data represented in
  frequency domain (that is after an FFT): how do we integrate this properly in
  the language.
\end{itemize}

\subsection{What the language should look like}
\begin{itemize}
\item Operators with multiple outputs as well as multiple inputs. We really live
  in a monoidal category with biproducts.
\item What is a good syntax for this? We could have a categorical syntax (Ã  la
  Faust) but having the opportunity to name wires seems to be nice, so both
  would be perfect (eg in $\lambda$-calculus we can do both $g\circ f$ and
  $\lambda x.g(f(x))$).
\item Typing system. We should begin with something simple.
\item We need a trace operator: instant feedback should be ruled out by either
  typing or checks for acyclicity (however feedbacks are legal in presence of a
  delay).
\item How do we type clocks properly?
\item The language should be high-level and implementation-independent. In
  particular, it would be nice to be able to compile audio algos both to int and
  float and compare the difference of performance.
\end{itemize}

\subsection{Further optimizations}
\begin{itemize}
\item We should implement all the classical optimizations: constant propagation,
  expression factorization, etc.
\item Some optims are also specific to the domain of application: merge for
  loops as much as possible, etc.
\item Since the code will be very specific, we can vectorize it easily and use
  SIMD operations. Even better, we can think of using very funny things such as
  compiling to graphic cards (Cuda or OpenCL) or VLSI.
\item We should distinguish between three kind of values.
  \begin{enumerate}
  \item \emph{constant values}: never change during time
  \item \emph{sparse values}: rarely change during time. In practice, this means
    that we can consider them as constant during a buffer. The typical example
    is a value read from an user input such as a GUI.
  \item \emph{values} which are neither constant or sparse.
  \end{enumerate}
  The constant values might be inferred automatically. However, sparse value
  might need some annotations.
\item The stream data might be a simple value (floats for audio) or an allocated
  value (images). In the last case, we should avoid copies and we need to do
  this in a clever way.
\end{itemize}

\section{State of the art}
A good starting point:
\url{http://en.wikipedia.org/wiki/Comparison_of_audio_synthesis_environments}

% \begin{tabular}{cccc}
%   &\begin{sideways}blabla\end{sideways}\\
%   ChucK&\\
%   Csound&\\
%   Faust&\\
%   Impromptu&\\
%   Max&\\
%   Nyquist&
% \end{tabular}

\subsubsection{ChucK}

\subsubsection{Csound}
\cite{csound}
Textual

\subsubsection{Faust}
\cite{faust}
Textual

\subsubsection{Impromptu}
\cite{impromptu} Textual with a Lisp syntax (Scheme). Very nice examples of ``live
coding'' of music by the author.

\subsubsection{Max}
\cite{max}

\subsubsection{Nsound}
\cite{nsound} C++ framework

\subsubsection{Nyquist}
\cite{nyquist}
Textual

\subsubsection{Pure Data}
A purely graphical graphical language~\cite{puredata}. Detailed
documentation~\cite{pd-doc}. The \emph{patches} (or \emph{canvases}) are build
from \emph{boxes} linked by wires. Two kind of data: \emph{messages} (our
events) and audio signals. There is a \emph{bang} message that boxes often
accept to trigger a computation. No detection of loops (stack overflows).

The language is not compiled, a toy compiler was
tried\footnote{\url{http://www.media.mit.edu/resenv/PuDAC/sw.html}} and
apparently already improves much performances. It would be nice to try with our compiler.

\subsubsection{PWGL}
\cite{pwgl}
Graphical

\subsubsection{Reaktor}
\cite{reaktor} Closed source. Tons of plugins. Graphical: nice GUI to control
synths + programming (\emph{patches} consist of \emph{modules} connected by
lines)

\subsubsection{SuperCollider}
\cite{supercollider}
Textual


\bibliographystyle{plain}
\bibliography{sound}
\end{document}
