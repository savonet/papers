\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{hyperref}
\usepackage{rotating}

\newcommand{\Var}{Var}

\newcommand{\TODO}[1]{\marginpar{\footnotesize #1}}

\title{Ideas for\\An Optimizing Compiler\\for Sound Analysis and Synthesis}
\author{Samuel Mimram}

\hypersetup{
  pdftitle={\csname @title\endcsname},
  pdfauthor={\csname @author\endcsname},
  unicode=true,
  colorlinks=true,
  linkcolor=black,
  citecolor=black,
  urlcolor=black
}

\begin{document}
\maketitle

\section{What we want}
\subsection{What we should be able to do}
\begin{itemize}
\item We want to be able to manipulate streams of data: audio (streams of
  samples), video (streams of images), etc.
\item We should distinguish between two kind of things that we manipulate:
  \emph{values} which are always available in a stream (samples in audio data)
  and \emph{events} which are punctual data (metadata, notes, etc.). For example
  the type for metadata is \verb|(string * string) event|.
\item We should be able to trigger a event of type unit when a data changes
  (typically when the audio data gets louder than a certain value): we need a
  function \verb|bool -> bool event| which triggers an event with the new value
  when the value has changed.
\item How do we use this function to program piecewise linear functions
  (typically ADSR envelopes)? We also need to be able to consider \emph{relative
    times} for this (decay is after beginning of attack + 20ms).
\item We should moreover be able to deal with \emph{partial streams} ie streams
  where data is not always available.
\item It would be very nice to have a good typing of data represented in
  frequency domain (that is after an FFT): how do we integrate this properly in
  the language.
\item Have a good notion of track. We should be able to use events for this.
\end{itemize}

\subsection{What the language should look like}
\begin{itemize}
\item Operators with multiple outputs as well as multiple inputs. We really live
  in a monoidal category with biproducts.
\item What is a good syntax for this? We could have a categorical syntax (Ã  la
  Faust) but having the opportunity to name wires seems to be nice, so both
  would be perfect (eg in $\lambda$-calculus we can do both $g\circ f$ and
  $\lambda x.g(f(x))$).
\item Typing system. We should begin with something simple.
\item We need a trace operator: instant feedback should be ruled out by either
  typing or checks for acyclicity (however feedbacks are legal in presence of a
  delay).
\item How do we type clocks properly?
\item The language should be high-level and implementation-independent. In
  particular, it would be nice to be able to compile audio algos both to int and
  float and compare the difference of performance.
\item Maybe do we need some limited form of dependent types. For example, to
  implement a function
  \begin{center}
    \texttt{map : $n$:int -> ('a -> 'a) -> ('a$\null^n$ -> 'a$\null^n$)}
  \end{center}
   which would apply a same function to every channel of a stream.
 \item Overloading for events / values? eg \texttt{+} can be given both types
   \begin{center}
     \verb|+ : int -> int|
     \qquad and\qquad
     \verb|+ : int event -> int event|
   \end{center}
   Do we want this for all operators?
\end{itemize}

\subsection{Further optimizations}
\begin{itemize}
\item We should implement all the classical optimizations: constant propagation,
  expression factorization, etc.
\item Some optims are also specific to the domain of application: merge for
  loops as much as possible, etc.
\item Since the code will be very specific, we can vectorize it easily and use
  SIMD operations. Even better, we can think of using very funny things such as
  compiling to graphic cards (Cuda or OpenCL) or VLSI.
\item We should distinguish between three kind of values.
  \begin{enumerate}
  \item \emph{constant values}: never change during time
  \item \emph{sparse values}: rarely change during time. In practice, this means
    that we can consider them as constant during a buffer. The typical example
    is a value read from an user input such as a GUI.
  \item \emph{values} which are neither constant or sparse.
  \end{enumerate}
  The constant values might be inferred automatically. However, sparse value
  might need some annotations.
\item The stream data might be a simple value (floats for audio) or an allocated
  value (images). In the last case, we should avoid copies and we need to do
  this in a clever way.
\end{itemize}

\section{The language}
\subsection{Terms}
Suppose given a set~$\Var$ of \emph{variables}. The syntax for terms~$M$ is
\[
M
\qquad::=\qquad
x
\qquad|\qquad
\lambda x.M
\qquad|\qquad
MM
\qquad|\qquad
M|M
\qquad|\qquad
0
\]
Substitution of a variable $x$ by a term~$N$ in a term~$M$, written~$M[N/x]$ is
defined inductively by
\[
\begin{array}{c@{\qquad}c}
  x[N/x]=N
  &
  y[N/x]=y
  \\
  (\lambda y.M)[N/x]=\lambda y.M[N/x]
  &
  (M_1M_2)[N/x]=(M_1[N/x])(M_2[N/x])
  \\
  (M_1|M_2)[N/x]=M_1[N/x]|M_2[N/x]
  &
  0[N/x]=0
\end{array}
\]
where~$y\neq x$. Terms are considered modulo $\alpha$-equivalence. We also
suppose that terms are associated on right wrt $|$ ie $M_1|(M_2|M_3)$ instead of
$(M_1|M_2)|M_3$ and that $0$ are removed ie $M$ instead of $M|0$.\TODO{The right
  way is to introduce an equivalence for this.}

The reductions rules are
\[
\begin{array}{r@{\quad}c@{\quad}l}
  (\lambda x.M)N&\longrightarrow&M[N/x]\\
  (\lambda x.M)(N_1|N_2)&\longrightarrow&(M[N_1/x])N_2\\
\end{array}
\]
Notice that they are not confluent!...

A few examples.
\begin{itemize}
\item the duplicator: $\lambda x.(x|x)$
\item the erasor: $\lambda x.0$
\item compose the two:\TODO{We have to make this example really work. With the
    actual rules the last reduction gives $\lambda y.0y$}
  \[
  \lambda y.(\lambda x.0)[(\lambda x.(x|x))y]
  \quad\longrightarrow\quad
  \lambda y.(\lambda x.0)(y|y)
  \quad\longrightarrow\quad
  \lambda y.(0|y)
  \quad=\quad
  \lambda y.y
  \]
\end{itemize}

\subsection{Types}

\section{Hot topics}
\subsection{A syntax with coarities and cocurryfication}
We want operators with coarities e.g. the operator \texttt{swap}, which
exchanges the two channels of a stereo stream, has two inputs of type
\texttt{audio} and two outputs of type \texttt{audio}\TODO{Actually, it might be
  more natural to give it a type with one input and one output both of type
  \texttt{(audio * audio)}, but anyway.}. We write its type as follows:
\begin{center}
  \verb|swap : (audio , audio) -> (audio , audio)|
\end{center}
The language should support currying, so \texttt{swap} can be transformed into
\begin{center}
  \verb|swap' : (audio * audio) -> (audio , audio)|
\end{center}
But the language should also support \emph{cocurrying}, so that \texttt{swap}
can also be transformed into
\begin{center}
  \verb|swap'' : (audio , audio) -> (audio * audio)|
\end{center}
Similarly to the usual arrow notation, a list \verb|(A,B,C,D)| on the left of an
arrow should be read as \verb|(A,(B,(C,(D))))|. We often write \verb|A| instead
of \verb|(A)|.

As usual, applications can be partial: from \verb|f : (A,B)->C| and \verb|a : A|
we can construct \verb|(f a) : B->C|. Notice that we should see the value
\verb|a| as \verb|a : ()->A|. So we have the following more general fact: from
\verb|f : (A,B)->C| and \verb|a : A'->A| we can construct
\verb|(f a) :(A',B)->C|. Naturally, things should go on dually for coarities:
from \verb|f : A->(B,C)| and \verb|b : B->B'| one can build
\verb|(f b) : A->(B',C)|. We call a \emph{covalue} a value of type \verb|A*|
which is by definition \verb|A->()|. So we have in particular, from
\verb|f : A->(B,C)| and \verb|b : B*| one can build \verb|(f b) : A->C|.

So far so good. We can even mix both mechanisms: from \verb|f : A->(B,C)| and
\verb|g : (B,D)->E| one can build \verb|(g f) : (A,D)->(E,C)|. Now, suppose that
$\texttt{C}=\texttt{D}$. How do we ``finalize'' the composition? Using a trace!
But this is arguably not very natural...

Notice that in this case, there is really no notion of input and output since we
also have the following isomorphisms:
\begin{center}
  \verb|A->(B,C)|
  \qquad$\cong$\qquad
  \verb|(A,C*)->B|
  \qquad
  etc.
\end{center}

Since it might be good to work up to commutation, we could try a labeled
alternative, but this would be quite verbose because we would have to explicit
all the cuts. Moreover, it is not quite clear which instance of a function we
are using. For example, suppose that we want to compute the composite
\verb|h : (x:A)->(y:D)| of
\begin{center}
  \verb|f : (x:A)->(x':B,x'':C)|
  \qquad and\qquad
  \verb|g : (y':B,y'':C)->(y:D)|
\end{center}
This could be done as follows:
\begin{verbatim}
let f1 = new f
let g1 = new g
cut f1.x' g1.y'
cut f1.y'' g1.y''
let h = f1 * g1
\end{verbatim}
The details of this have to be thought in details and it is not very clear how
to do it in a way which is not too verbose. The idea of labels and colabels is
however interesting. In particular, optional coarguments mean that a default
continuation can be given.

\section{State of the art}
Wikipedia gives a good starting
point\footnote{\url{http://en.wikipedia.org/wiki/Comparison_of_audio_synthesis_environments}}.

% \begin{tabular}{cccc}
%   &\begin{sideways}blabla\end{sideways}\\
%   ChucK&\\
%   Csound&\\
%   Faust&\\
%   Impromptu&\\
%   Max&\\
%   Nyquist&
% \end{tabular}

\subsubsection{ChucK}
A textual programming language with a C-like syntax, compiled
on-the-fly\cite{chuck}. Their ``new operator'' called \emph{ChucK} and written
\texttt{=>} is a massively overloaded operator for various things such as
variable assignation, composition of operators, etc., which makes the language a
bit messy. Has a notion of \emph{event}. The language is globally messy (I
repeat).

\subsubsection{Csound}
Textual programming language with a syntax inherited from ancient
times~\cite{csound}.

\subsubsection{Faust}
\cite{faust}
Textual

\subsubsection{Impromptu}
\cite{impromptu} Textual with a Lisp syntax (Scheme). Very nice examples of ``live
coding'' of music by the author.

\subsubsection{Max}
\cite{max}

\subsubsection{Nsound}
A C++ framework~\cite{nsound}, ie just like ocaml-mm but in C++.

\subsubsection{Nyquist}
A textual programming language~\cite{nyquist}. It looks like a regular
programming language where all operators would implicitly take a time
parameter. Interesting notion of \emph{time warp} which locally modifies time by
another function.


\subsubsection{Pure Data}
A purely graphical graphical language~\cite{puredata}. Detailed
documentation~\cite{pd-doc}. The \emph{patches} (or \emph{canvases}) are build
from \emph{boxes} linked by wires. Two kind of data: \emph{messages} (our
events) and audio signals. There is a \emph{bang} message that boxes often
accept to trigger a computation. No detection of loops (stack overflows).

The language is not compiled, a toy compiler was
tried\footnote{\url{http://www.media.mit.edu/resenv/PuDAC/sw.html}} and
apparently already improves much performances. It would be nice to try with our compiler.

\subsubsection{PWGL}
\cite{pwgl}
Graphical

\subsubsection{Reaktor}
\cite{reaktor} Closed source. Tons of plugins. Graphical: nice GUI to control
synths + programming (\emph{patches} consist of \emph{modules} connected by
lines)

\subsubsection{SuperCollider}
Object-oriented textual programming language~\cite{supercollider}.



\bibliographystyle{plain}
\bibliography{sound}
\end{document}
