\documentclass{llncs}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{hyperref}
\usepackage{wrapfig}

\pagestyle{plain}

\newcommand{\liquidsoap}{Liquidsoap}
\newcommand{\savonet}{Savonet}
% DB je retrouve pas de source claire pour l'italique pour les abbrev latines,
%   mais la virgule après i.e. et e.g. c'est clairement la règle
% SM c'est moche, je préfère sans, même si c'est la convention c'est très rarement appliqué
\newcommand{\eg}{{e.g.}}
\newcommand{\ie}{{i.e.}}
\newcommand{\cf}{{cf.~}}
\newcommand{\TODO}[1]{\marginpar{\tiny #1}}
\newcommand{\ignore}[1]{}

\usepackage{graphicx}
\usepackage{xypic}

\usepackage{tikz}
\usetikzlibrary{snakes}

\title{\liquidsoap{}:\\
  a High-Level Programming~Language\\
  for Multimedia~Streaming}
\author{David Baelde\inst{1} \and Romain Beauxis\inst{2} \and Samuel Mimram\inst{3}}
\institute{
  University of Minnesota, USA
  \and
  Tulane University, USA
  \and
  CEA LIST -- LMeASI, France
}

\hypersetup{
  pdftitle={\csname @title\endcsname},
  pdfauthor={David Baelde, Romain Beauxis and Samuel Mimram},
  unicode=true,
  colorlinks=true,
  linkcolor=black,
  citecolor=black,
  urlcolor=black
}

\hyphenation{pa-ra-me-trized}

\begin{document}
\maketitle

\begin{abstract}
  Generating multimedia streams, such as in a webradio, is a task which is
  complex and difficult to adapt to every users' needs. We introduce a novel
  approach in order to achieve it, based on a dedicated high-level functional
  programming language, called \emph{\liquidsoap{}}, for generating,
  manipulating and broadcasting multimedia streams. Unlike traditional
  approaches, which are based on configuration files or static graphical
  interfaces, it also allows the user to build complex and highly customized
  systems. This language is based on a model for streams and contains operators
  and constructions, which make it adapted to the generation of streams. The
  interpreter of the language also ensures many properties concerning the good
  execution of the stream generation.\TODO{expliquer qu'on insiste sur typage
    des streams + clocks}
  % We describe a model that supports a rich collection of operators (track
  % scheduling, jingle insertion, mix, metadata updates, various transitions), and
  % some aspects of language design that make it adapted to the application
  % domain.
\end{abstract}

The widespread adoption of broadband internet in the last decades has
changed a lot our way of generating and transmitting information. Classical
devices from the analog era, such as television or radio broadcasting devices
have been rapidly adapted to the digital world in order to benefit from the new
technologies available. Whilst analog devices were mostly based on hardware
implementations, their digital counterpart often consists in software
implementations,
% , \eg{} hardware
% PBX for phone communications being replaced by software like Asterisk and IP
% phones.
which potentially offers much more flexibility and modularity in their design.
% and allow updates, both for bugfix and new features, at virtually no cost.
% In this context of improvements, updates and enhancements of old technologies,
% we are here specifically interested in adapting audio and video broadcasting
% techniques to the digital world.
% So, creating and broadcasting a stream of multimedia data with recent computers
% has become technically very easy.
However, we believe that the current software technologies to perform such tasks
have not yet fully brought the new ideas which are necessary in order to really
benefit from the new possibilities offered by modern computing devices.

We are specifically interested here in the generation of multimedia streams
(containing audio or video). For example, many webradios are continuously
broadcasting audio data streams, and people can connect to these in order to
listen to the radios. At first, generating the streams might seem really simple:
it is just a bunch of concatenated audio files. However, in practice the needs
of real-world radio makers are much higher than this, and designing a generator
for multimedia streams needs a lot of flexibility in order to be able to cope
with most of the expectations and requirements of users. For instance, a radio
stream may have jingles announcing next coming shows or commercials. It may also
play those jingles at a regular interval of time, between songs or on top of
them. Also, a radio program may be composed of automatic playlist for a certain
period, \eg{} during the night, and live shows during the day. Similarly, one
may want to control and process the data before broadcasting it to the public,
performing tasks like volume normalization, cross-fading between tracks
(possibly parameterized by the respective volumes of the old and new tracks or
predefined settings), blanks removal (nobody wants to listen to silence),
etc. Moreover, the generation of the stream should be rock-solid: most webradios
are broadcasting automatically 24/7 and don't want to have to manually restart
the generator if it crashes after a few hours or a few days.

Those examples, among many others, show the need for very flexible and modular
solutions for creating and broadcasting multimedia data. Most of the currently
available tools to broadcast multimedia data over the Internet (such as Darkice,
Ezstream, VideoLAN, Rivendell or SAM Broadcaster) consist of straightforward
adaptation of classical streaming technologies, based on
predefined interfaces, such as a virtual mixing console or static file-based
setups. Those tools, although quite powerful, are usually very hard to adapt to
a particular need and are more and more often perceived as limited by the very
\TODO{DB "new" c'est abusé}
\TODO{RB c ok avec innovative ?}
constrained design of the program. Here, we present an innovative methodology for
achieving the task based on a dedicated \emph{programming language} called
\emph{Liquidsoap}, which brings much more flexibility and has proved in practice
to be adapted to the needs of a wide variety of users' requirements.

Programming languages are a particularly important aspect of modern software
technologies.  Whether general or domain-specific, programming languages are
often the right tool to release creativity and flexibility for creating new
applications. They have been used in various practical contexts to bring
flexibility and overcome static pre-defined paradigms. One may, for instance,
think of Perl, invented to allow powerful and flexible word-based treatments, or
PHP, which allows to easily create dynamic web pages. We believe that a good
programming language should follow three fundamental principles: it should be
\begin{enumerate}
\item \emph{adapted}: users should be able to perform, most of the tasks in the
  domain of application of the language (generating multimedia streams in our
  case);
\item \emph{simple}: users should be able to perform the tasks in a simple way
  (this means that it should be reasonably concise, but also reasonably
  understandable -- keep in mind that people willing to generate webradios are
  far from being all good programmers);
\item \emph{safe}: the compiler should perform checks to avoid as many bugs as
  possible (a stream generator has for example to ensure that there will always
  be data to stream).
\end{enumerate}
Designing a programming language that fulfills these requirements is not an easy task. 
Since the concept is quite new for the generation of streams, a
lot of time was spent to identify the needs of potential users, and to find the
right constructions and operators to build streams. The description of these is
one of the main interests of the paper: we both detail the abstract model for
streams underlying our software, and describe the actual programming language
\liquidsoap{}. Interestingly, we have been able to reuse and adapt classical
techniques and tools for programming languages, which turn out to fit and be
quite natural in this context: the language \liquidsoap{} is functional (which
confers a lot of expressiveness to it) and strongly typed (which allows to have
strong guarantees on the behavior the stream generation).

We first describe the language and its underlying model for streams in
Section~1, and then detail the typing systems as well as the guarantees that it
provides in Section~2.\TODO{indiquer le vrai plan : on insiste sur deux
  nouveautés importantes (typage des streams + clocks)}

\section{Liquidsoap}
\subsection{Streaming model}
\label{sec:model}
\begin{wrapfigure}{r}{7.5cm}
  \vspace{-7.5ex}
  \begin{center}
    \includegraphics{stream}
  \end{center}
  \vspace{-3ex}
  \caption{A \liquidsoap{} stream}
  \label{fig:stream}
  \vspace{-4ex}
  % Stream.png: 500x132 pixel, 91dpi, 14.03x3.70 cm, bb=0 0 398 105
\end{wrapfigure}
A stream can be understood as a timed sequence of data.
In digital signal processing, it will simply be an infinite sequence of 
samples | floating point values for audio, images for video.
However, multimedia streaming also involves high-level notions.
A \emph{stream}, in \liquidsoap{}, is a succession of \emph{tracks}, annotated
with \textit{metadata}. The tracks can be thought
as individual songs on a musical radio show. 
Metadata are punctual markers storing data, which can occur at any instant in the
stream, and are constituted of a pairs of strings storing the name of
the metadata and its value. They are used to store various information about the
stream such as copyright information (title, artist, etc. of
the current track) or custom information about tracks (for example how loud it
should be played).
Finally, tracks contain data, which consists of float samples 
(for audio data), images (for video data), etc. (see Section~\ref{sec:content}). 
Figure~\ref{fig:stream} represents an example of a stream in \liquidsoap{}.

\TODO{Do we allow fallible streams or fallible sources?
  Is there a hole of a certain duration between tracks in a stream,
  or just a failure to produce by the source.
  I think it's the latter but I'm not sure.}
\TODO{RB I think with 1.0.0. we allow holes in a stream
but I do not think it is appropriate to go into 
these details here..}

Streams are generated on the fly interactively by operators which are parametrized by various 
external factors (variables possibly modified by external interfaces and metadata in particular).
In \liquidsoap{}, a stream generator is called a \emph{source}. Some sources
purely produce a stream, getting it from an external device (such as a file, a
sound card or network) or are synthesizing it. Many other sources are actually
operating on other sources in the sense that they produce a stream based on input
streams given by other sources. Abstractly, the program describing the
generation of a stream can thus be represented by a directed acyclic graph,
whose nodes are the sources and whose edges indicate dependencies between
sources (an example is given in Figure~\ref{fig:simple}).

% Given an acyclic graph describing a stream generator, the roots of the graph are the operator that create 
% the initial streams, called \textit{sources}. Those sources can be created from a single file, a playlist, an HTTP input,
% the sound card, etc. The sources are then modified and composed with each other using 
% \textit{operators} that, for instance, play a source if it is available or a second one otherwise, or modify
% the metadata, mix the audio data of two sources, etc.
% Finally, the leaves of the graph describe the \textit{outputs} of the stream. Those outputs consist, for instance,
%% DB first occurrence of icecast, never introduced
% of playing the stream on the local sound card, saving it to a file or sending it to and Icecast server. 
% For this initial description, we suppose that the graph has only one output.

Some sources have a particular status: not only do they compute a stream like any
other source, but they also perform some observable tasks, typically outputting
their stream somewhere. These are called \emph{active} sources. Stream
generation is performed ``on demand'': active sources actively attempt to
produce their stream, obtaining data from their input sources which in turn
obtain data from their dependent sources, and so on. An important consequence of
this is the fact that sources do not constantly stream: if a source would
produce a stream which is not needed by any active source then it is actually
frozen in time. This avoids useless computations but is also crucial to obtain
the expected expressiveness. For example, a \texttt{rotation} operator will play
alternatively several sources, but should only rotate at the end of tracks, and
its unused sources should not keep streaming, otherwise we might find them in
the middle of a track when we come back to playing them. Likewise, we need to be
able to insert a jingle in between two tracks of a stream, which involves
momentarily stopping it. Sources are also allowed themselves to \emph{fail},
\ie{} refuse to stream at some point in the time at the end of a track (think
for example of a \texttt{playlist} operator which has a limited number of files
to play).

\subsection{A language for building streaming systems}

Based on the streaming model presented above, \liquidsoap{} provides the user
with a convenient high-level language for describing streaming systems.
Although our language borrows from other functional programming languages, it is
has been designed from scratch in order to be able to have a dedicated static
typing discipline together a very user-friendly language. 
It is implemented in OCaml and uses several C libraries 
through external bindings, most of them also developed within the 
\savonet{} project. The code contains approximatively $20$K lines of
OCaml code and $10$K lines of C code and runs on all major systems, including
Linux, Mac OSX and Windows.

One of the main goal which has motivated the design of the \liquidsoap{}
language is that it should be very accessible, even to non-programmers. It
turned out that having a functional programming language is very natural (\cf
Section~\ref{sec:transitions}). The built-in functions of the language often
have a large number of parameters, many of which have reasonable default values:
it would be very cumbersome to have to write them all each time, in the right
order. In order to address this, we have designed a new extension of
$\lambda$-calculus with labeled arguments and multi-abstractions which makes it
comfortable to use the scripting
API~\cite{baelde-mimram:webradio-lambda}. Having designed our own language also
allowed us to integrate a few domain-specific extensions, in particular
a browsable documentation of the scripting API and helpful error messages. In
practice, many of the users of \liquidsoap{} are motivated by creating a radio
and not very familiar with programming, so it can be considered that the design of
the language was a reasonable success from this point of view.

An other motivation was to ensure some safety properties of the stream
generation. A script in \liquidsoap{} describes a system that is intended to run
for months, some parts of whose rarely triggered, and it would be very
disappointing to notice a typo or a basic type error only after a particular
part of the code is used for an important event. In order to ensure essential
safety properties, the language is statically strongly typed. We want to put as
much static analysis as possible, as long as it doesn't put the burden on the
user, \ie{} all types should be inferred. As we shall see, \liquidsoap{} also
provides a few useful dynamic analysis.

\begin{figure}[t]
 \begin{center}
\[
\xymatrix{
  *+[F]{\mathtt{input.http}}\ar[r]&*+[F]{\mathtt{fallback}}\ar[r]&
  *+[F]{\mathtt{normalize}}\ar[r]&
  *+<10pt>[F=:<30pt>]{\mathtt{output.icecast}}\\
  *+[F]{\mathtt{playlist}}\ar[ur]&\\
}
\]
\end{center}
 \caption{A simple streaming system}
 \label{fig:simple}
 % Stream.png: 500x132 pixel, 91dpi, 14.03x3.70 cm, bb=0 0 398 105
\end{figure}

The current paper can be read without a prior understanding of the language and
its typing system, the reader interested into a detailed presentation is referred
to~\cite{baelde-mimram:webradio-lambda}. We simply recall that the evaluation of
a \liquidsoap{} script triggers the construction of various sources, built from
various operators built into the language. It also performs some sanity checks
such as checking that a source is infallible \ie{} always has data available. 
For example, the following script defines two elementary sources, respectively 
reading from an HTTP stream and a playlist of files, composed in a fallback 
(\ie{} if the HTTP stream is ended or broken then the playlist is used), 
filtered through a volume normalizer and sent to an Icecast server which 
broadcasts the stream to the listeners:%\TODO{DB define icecast}
\begin{verbatim}
output.icecast(%vorbis,mount="myradio",
  normalize(fallback([input.http("http://other.net/radio"),
                      playlist("listing.txt")])))
\end{verbatim}
The graph underlying the system resulting from the execution of that
script is shown in Figure~\ref{fig:simple}.\TODO{mount est un exemple de label}

% \subsection{Fallibility}
% 
% \TODO{DB selon la place, on peut envisager de faire sauter cette section;
%   si on la laisse on peut la merger avec la précédente, en plus compact}
% 
% Finally, the information of whether or not a stream can be assumed to be
% infinite is also carried by the graph. For instance, if a source is created from
% a single file, one can try to decode it before starting streaming. If the file
% can be decoded, and one can assume that the file will not be deleted later, and
% then the source can be considered infallible. Later on, if this source is used,
% for instance in an operator that plays the first available source, then the
% source resulting of this operator is also infallible.  By induction over the
% vertices of the graph, each node can be considered fallible or not. Eventually,
% an infallible output can be considered as describing an infinite stream, while a
% fallible output describes a stream that may not be infinite.

\subsection{Efficiency}

\TODO{DB In the JFLA paper we have a quick benchmark of the impact
  of changing the frame size from 1 to 100 to 1000.
  Also, can we still compete well with ices?}

An important aspect of the implementation is efficiency, and, specifically in \liquidsoap{},
avoiding multiple copies of the stream's data. Thus, we use a
reference passing mechanism based on \textit{frames}. A frame is a
chunk of data of fixed duration that represents a portion of the stream.
An active source instantiates a frame and tries to fill it by passing a reference
to that frame to its underlying sources.
The frames used to generate streams are passed as memory pointers, thus
avoids copying data in memory.
\TODO{DB at this point the reader doesn't see why several frames are needed}
\TODO{RB I think it is ok now..}

Unfortunately, it is not always possible to avoid copying data. For instance, one may want to have 
several outputs of the same  stream, \eg\ one to a local file for archiving purposes and another one to an 
Icecast server to be broadcasted.
In this case, the two outputs in the graph are connected to the same source. 
Hence, when those output transmit their frame to this source to be filled, the 
operator should fill them with the same data.

\begin{figure}[h]
 \begin{center}
\[
\xymatrix{
  *+[F]{\mathtt{input.http}}\ar[r]&*+[F]{\mathtt{fallback}}\ar[r]&
  *+[F]{\mathtt{normalize}}\ar[r]\ar[dr]&
  *+<10pt>[F=:<30pt>]{\mathtt{output.icecast}}\\
  *+[F]{\mathtt{playlist}}\ar[ur]& & & *+<10pt>[F=:<30pt>]{\mathtt{output.file}}\\
}
\]
\end{center}
 \caption{A streaming system with sharing}
 % Stream.png: 500x132 pixel, 91dpi, 14.03x3.70 cm, bb=0 0 398 105
\end{figure}

For this reason, the first time that the source is asked to fill a frame, it 
operates as described before. However, the second time, it should just fill the frame 
with the data gathered during the first call, which implies \textit{caching} the data obtained 
during the first call. 
\TODO{DB: What about the third time, fourth? When does it stop?
  We need to talk about clock cycles to avoid confusing the reader.}
Once all the filling operations have been done, the sources are informed that the 
stream has moved to the next frame and reset their cache. 

Finally, the necessity for a node to cache its current frame is detected when instantiating 
the stream generator, thus copying data in memory only when it is necessary.
\TODO{DB This paragraph doesn't say much; a little more could be said after
  transitions are evoked.}

\subsection{Functional transitions}
\label{sec:transitions}

A particularly interesting application of functional programming in \liquidsoap{} 
is the case of \textit{transitions}. In \liquidsoap{}, some source can interactively
select between several sources. For instance the source defined by 
\texttt{fallback([s, r])} fills its frame using source \texttt{s} if it is available
or source \texttt{r} otherwise. When switching from one source to another, it is 
possible to specify a transition, which is given as a function of type:
\texttt{(source * source) $\rightarrow$ source}, \ie{} a function that takes
the two sources, the old and new sources, and return a new source, which
gives the transition between them.

For instance, the following code defines a fallback source which performs
a crossfade when switching from one source to another:
\begin{verbatim}
 def crossfade(old,new) = 
   add([fade.in(new), fade.out(old)])
 end
 f = fallback(transitions=[crossfade, crossfade],
              [s, r])
\end{verbatim}
Figure~\ref{cross-fig} illustrates the result of this transition.

\begin{figure}[h]
 \begin{center}
\begin{tikzpicture}[xscale=0.8,yscale=0.8]
\draw[->] (0,0) -- (0,2.5);
\draw (-0.1,2) -- (0.1,2);
\draw (0,2) node[anchor=east]{100};
\draw (0,0) node[anchor=east]{0};
\draw[->] (0,0) -- (7.5,0);
\foreach \x in {1,2,3,4,5,6,7} \draw (\x,-0.1) -- (\x,0.1);
\draw (0,2.5) node[anchor=south]{volume (\%)};
\draw (7.5,0) node[anchor=west]{time (sec)};
\draw (0,2) -- (2,2) -- (5,0);
\draw (3,0) -- (5,2) -- (7.5,2);
\draw (1,2) node[anchor=south]{old};
\draw (6,2) node[anchor=south]{new};
\end{tikzpicture}
\end{center}
 \caption{A crossfade transition between two sources}
 \label{cross-fig}
 % Stream.png: 500x132 pixel, 91dpi, 14.03x3.70 cm, bb=0 0 398 105
\end{figure}

Because any function can be used to define the transitions, the 
possibilities offered are very important. For instance, it is possible
to define \texttt{smooth\_add}, a source composed of a main source, 
the tracks of a radio program for instance, and a source of jingles. 
When a new jingle is available, \texttt{smooth\_add} reduces the volume of 
the main source, supperposes the jingle to the current track, and 
increases the volume of the main track back when the jingle is finished,
producing a dynamic jingle incrustation very easy to use and quite appreciated
by some users.\footnote{Unfortunately, the code of this function would not 
fit in the margin. It is available online at this address: 
\url{http://bit.ly/aHE0G0}}

\section{Heterogeneous stream contents}
\label{sec:content}

\input{hetero.tex}

\section{Clocks}

\input{clocks.tex}

\section{Related work}

\liquidsoap\ is obviously different from tools such as Ices or Darkice in
that it offers the user the freedom to assemble a stream
for a vast variety of operators, through a scripting
language rather than more traditional configuration languages.

\liquidsoap{} has similarities with multimedia streaming libraries.
For example, GStreamer defines a model of stream, and its API
can be used to define streaming systems in various programming
languages (primarily coded in C, the library has also been
ported to many other languages).
There are two differences, however.
First, the stream model that we use is more high-level than
GStreamer. % TODO check
Second and more importantly,
our programming language makes it much simpler
to compose operators; all the low level aspects are hidden
from the user.

A last class of related tools is digital signal processing (DSP) languages.
An interesting system in this category is Faust~\cite{faust},
which provides a high-level functional programming language for
describing stream processing devices,
and compiles this language down to C++, which enables an integration
with various other systems.
Again, the traditional notion of stream in DSP is too weak for our
purpose, but this is only a shallow difference.
\liquidsoap{} does not build new operators but only assembles pre-defined
operators. In contrast, Faust compiles a single new operator at each
compilation, aggregating the basic operations used in the script
and optimizing their combination.
\TODO{DB unlike faust, liquidsoap is interpreted}
It would be very interesting to interface \liquidsoap\ with such a tool,
or import some of their techniques. This could certainly be done with
DSP operators, and would allow us to program them efficiently from
the scripting language rather than in OCaml. Further, it should
be studied whether such an approach can be undertaken in general with
the kind of streaming system that we are considering.


TODO: has been used in research~\cite{baccigalupo2007case,baccigalupo2007sharing}
\TODO{on peut citer, je sais pas où, mais j'insisterais pas sur
  l'utilisation en recherche (c'est une utilisation comme une autre,
la recherche de claudio est indépendante de liq)}

\section{Conclusion}

Documentation, errors, user friendliness.
Requests.

\bibliographystyle{abbrv}
\bibliography{biblio}
\end{document}
