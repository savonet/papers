\documentclass{llncs}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{hyperref}
\usepackage{wrapfig}
\usepackage{proof}

\pagestyle{plain}

\newcommand{\liquidsoap}{Liquidsoap}
\newcommand{\savonet}{Savonet}
% DB je retrouve pas de source claire pour l'italique pour les abbrev latines,
%   mais la virgule après i.e. et e.g. c'est clairement la règle
% SM c'est moche, je préfère sans, même si c'est la convention c'est très rarement appliqué
% DB bah moi je préfère avec :)
%    je t'ai déja passé l'italique (qui se justifie pourtant vu que c'est
%    du latin)
% SM juste pour la blague, je les re-vire
\newcommand{\eg}{{e.g.}}
\newcommand{\ie}{{i.e.}}
\newcommand{\cf}{{cf.~}}
\newcommand{\TODO}[1]{\marginpar{\tiny #1}}
\newcommand{\ignore}[1]{}
% useless space around captions
\newcommand{\fcaption}[1]{\vspace{-3ex}\caption{#1}\vspace{-4ex}}

\newcommand{\sub}{<:}

\usepackage{graphicx}
\usepackage[matrix,arrow,frame]{xy}

\usepackage{tikz}
\usetikzlibrary{snakes}

\title{\liquidsoap{}:\\
  a High-Level Programming~Language\\
  for Multimedia~Streaming}
\author{David Baelde\inst{1} \and Romain Beauxis\inst{2} \and Samuel Mimram\inst{3}}
\institute{
  University of Minnesota, USA
  \and
  Tulane University, USA
  \and
  CEA LIST -- LMeASI, France
}

\hypersetup{
  pdftitle={\csname @title\endcsname},
  pdfauthor={David Baelde, Romain Beauxis and Samuel Mimram},
  unicode=true,
  colorlinks=true,
  linkcolor=black,
  citecolor=black,
  urlcolor=black
}

\hyphenation{pa-ra-me-trized}

\begin{document}
\maketitle

% \vspace{-4ex}

\begin{abstract}
  Generating multimedia streams, such as in a webradio, is a task which is
  complex and difficult to adapt to every users' needs. We introduce a novel
  approach in order to achieve it, based on a dedicated high-level functional
  programming language, called \emph{\liquidsoap{}}, for generating,
  manipulating and broadcasting multimedia streams. Unlike traditional
  approaches, which are based on configuration files or static graphical
  interfaces, it also allows the user to build complex and highly customized
  systems. This language is based on a model for streams and contains operators
  and constructions, which make it adapted to the generation of streams. The
  interpreter of the language also ensures many properties concerning the good
  execution of the stream generation.
  % We describe a model that supports a rich collection of operators (track
  % scheduling, jingle insertion, mix, metadata updates, various transitions), and
  % some aspects of language design that make it adapted to the application
  % domain.
\end{abstract}

The widespread adoption of broadband internet in the last decades has
changed a lot our way of generating and transmitting information. Classical
devices from the analog era, such as television or radio broadcasting devices
have been rapidly adapted to the digital world in order to benefit from the new
technologies available. Whilst analog devices were mostly based on hardware
implementations, their digital counterpart often consists in software
implementations,
% , \eg{} hardware
% PBX for phone communications being replaced by software like Asterisk and IP
% phones.
which potentially offers much more flexibility and modularity in their design.
% and allow updates, both for bugfix and new features, at virtually no cost.
% In this context of improvements, updates and enhancements of old technologies,
% we are here specifically interested in adapting audio and video broadcasting
% techniques to the digital world.
% So, creating and broadcasting a stream of multimedia data with recent computers
% has become technically very easy.
However, we believe that the current software technologies to perform such tasks
have not yet fully brought the new ideas which are necessary in order to really
benefit from the new possibilities offered by modern computing devices.

We are specifically interested here in the generation of multimedia streams
(containing audio or video). For example, many webradios are continuously
broadcasting audio data streams, and people can connect to these in order to
listen to the radios. At first, generating the streams might seem really simple:
it is just a bunch of concatenated audio files. However, in practice the needs
of real-world radio makers are much higher than this, and designing a generator
for multimedia streams needs a lot of flexibility in order to be able to cope
with most of the expectations and requirements of users. For instance, a radio
stream may have jingles announcing next coming shows or commercials. It may also
play those jingles at a regular interval of time, between songs or on top of
them. Also, a radio program may be composed of automatic playlist for a certain
period, \eg{} during the night, and live shows during the day. Similarly, one
may want to control and process the data before broadcasting it to the public,
performing tasks like volume normalization, cross-fading between tracks
(possibly parameterized by the respective volumes of the old and new tracks or
predefined settings), blanks removal (nobody wants to listen to silence),
etc. Moreover, the generation of the stream should be rock-solid: most webradios
are broadcasting automatically 24/7 and don't want to have to manually restart
the generator if it crashes after a few hours or a few days.

Those examples, among many others, show the need for very flexible and modular
solutions for creating and broadcasting multimedia data. Most of the currently
available tools to broadcast multimedia data over the Internet (such as Darkice,
Ezstream, VideoLAN, Rivendell or SAM Broadcaster) consist of straightforward
adaptation of classical streaming technologies, based on
predefined interfaces, such as a virtual mixing console or static file-based
setups. Those tools, although quite powerful, are usually very hard to adapt to
a particular need and are more and more often perceived as limited by the very
\TODO{DB "new" c'est abusé}
\TODO{RB c ok avec innovative ?}
constrained design of the program. Here, we present an innovative methodology for
achieving the task based on a dedicated \emph{programming language} called
\emph{Liquidsoap}, which brings much more flexibility and has proved in practice
to be adapted to the needs of a wide variety of users' requirements.

Programming languages are a particularly important aspect of modern software
technologies.  Whether general or domain-specific, programming languages are
often the right tool to release creativity and flexibility for creating new
applications. They have been used in various practical contexts to bring
flexibility and overcome static pre-defined paradigms. One may, for instance,
think of Perl, invented to allow powerful and flexible word-based treatments, or
PHP, which allows to easily create dynamic web pages. We believe that a good
programming language should follow three fundamental principles: it should be
\begin{enumerate}
\item \emph{adapted}: users should be able to perform, most of the tasks in the
  domain of application of the language (generating multimedia streams in our
  case);
\item \emph{simple}: users should be able to perform the tasks in a simple way
  (this means that it should be reasonably concise, but also reasonably
  understandable -- keep in mind that people willing to generate webradios are
  far from being all good programmers);
\item \emph{safe}: the compiler should perform checks to avoid as many bugs as
  possible (a stream generator has for example to ensure that there will always
  be data to stream).
\end{enumerate}
Designing a programming language that fulfills these requirements is not an easy task.
Since the concept is quite new for the generation of streams, a
lot of time was spent to identify the needs of potential users, and to find the
right constructions and operators to build streams. The description of these is
one of the main interests of the paper: we both detail the abstract model for
streams underlying our software, and describe the actual programming language
\liquidsoap{}. Interestingly, we have been able to reuse and adapt classical
techniques and tools for programming languages, which turn out to fit and be
quite natural in this context: the language \liquidsoap{} is functional (which
confers a lot of expressiveness to it) and strongly typed (which allows to have
strong guarantees on the behavior the stream generation).

The aim of the article is to present not only the programming language
\liquidsoap{}, but also the solutions that had to be found for problems which
are specifically raised by to our domain of application. We first give a broad
overview of the language and its underlying model of streams in
Section~\ref{sec:liq}. We then illustrate the typing system and the need for
dedicated constructions in order to type multimedia streams in
Section~\ref{sec:content}. Finally, we describe in Section~\ref{sec:clocks} the
problems raised by the possibly multiple sources of time in our programming
language and how we handle it.

% We first describe the language and its underlying model for streams in
% Section~1, and then detail the typing systems as well as the guarantees that it
% provides in Section~2.\TODO{indiquer le vrai plan : on insiste sur deux
 % nouveautés importantes (typage des streams + clocks)}

\section{Liquidsoap}
\label{sec:liq}
\subsection{Streaming model}
\label{sec:model}
\begin{wrapfigure}{r}{7.5cm}
  \vspace{-7.5ex}
  \begin{center}
    \includegraphics{stream}
  \end{center}
  \fcaption{A \liquidsoap{} stream}
  \label{fig:stream}
  % Stream.png: 500x132 pixel, 91dpi, 14.03x3.70 cm, bb=0 0 398 105
\end{wrapfigure}
A stream can be understood as a timed sequence of data.
In digital signal processing, it will simply be an infinite sequence of 
samples -- floating point values for audio, images for video.
However, multimedia streaming also involves high-level notions.
A \emph{stream}, in \liquidsoap{}, is a succession of \emph{tracks}, annotated
with \textit{metadata}. The tracks can be thought
as individual songs on a musical radio show. 
Metadata are punctual markers storing data, which can occur at any instant in the
stream, and are constituted of a pair of strings consisting of the name of
the metadata and its value. They are used to store various information about the
stream such as copyright information (title or artist of
the current track) or custom information about tracks (for example how loud it
should be played).
Finally, tracks contain data, which consist of float samples 
(for audio data), images (for video data), etc. (see Section~\ref{sec:content}).
A schematic representation of a stream is given in Figure~\ref{fig:stream}.

\TODO{Do we allow fallible streams or fallible sources?
  Is there a hole of a certain duration between tracks in a stream,
  or just a failure to produce by the source.
  I think it's the latter but I'm not sure.}
\TODO{RB I think with 1.0.0. we allow holes in a stream
but I do not think it is appropriate to go into 
these details here..}

Streams are generated on the fly interactively by operators which are parametrized by various 
external factors (variables possibly modified by external interfaces and metadata in particular).
In \liquidsoap{}, a stream generator is called a \emph{source}. Some sources
purely produce a stream, getting it from an external device (such as a file, a
sound card or network) or are synthesizing it. Many other sources are actually
operating on other sources in the sense that they produce a stream based on input
streams given by other sources. Abstractly, the program describing the
generation of a stream can thus be represented by a directed acyclic graph,
whose nodes are the sources and whose edges indicate dependencies between
sources (an example is given in Figure~\ref{fig:simple}).

% Given an acyclic graph describing a stream generator, the roots of the graph are the operator that create 
% the initial streams, called \textit{sources}. Those sources can be created from a single file, a playlist, an HTTP input,
% the sound card, etc. The sources are then modified and composed with each other using 
% \textit{operators} that, for instance, play a source if it is available or a second one otherwise, or modify
% the metadata, mix the audio data of two sources, etc.
% Finally, the leaves of the graph describe the \textit{outputs} of the stream. Those outputs consist, for instance,
%% DB first occurrence of icecast, never introduced
% of playing the stream on the local sound card, saving it to a file or sending it to and Icecast server. 
% For this initial description, we suppose that the graph has only one output.

Some sources have a particular status: not only do they compute a stream like any
other source, but they also perform some observable tasks, typically outputting
their stream somewhere. These are called \emph{active} sources. Stream
generation is performed ``on demand'': active sources actively attempt to
produce their stream, obtaining data from their input sources which in turn
obtain data from their dependent sources, and so on. An important consequence of
this is the fact that sources do not constantly stream: if a source would
produce a stream which is not needed by any active source then it is actually
frozen in time. This avoids useless computations, but is also crucial to obtain
the expected expressiveness. For example, a \texttt{rotation} operator will play
alternatively several sources, but should only rotate at the end of tracks, and
its unused sources should not keep streaming, otherwise we might find them in
the middle of a track when we come back to playing them. Likewise, we need to be
able to insert a jingle in between two tracks of a stream, which involves
momentarily stopping it. Sources are also allowed themselves to \emph{fail},
\ie{} refuse to stream at some point in the time at the end of a track (think
for example of a \texttt{playlist} operator which has a limited number of files
to play).

\subsection{A language for building streaming systems}

Based on the streaming model presented above, \liquidsoap{} provides the user
with a convenient high-level language for describing streaming systems.
Although our language borrows from other functional programming languages, it is
has been designed from scratch in order to be able to have a dedicated static
typing discipline together a very user-friendly language. 
It is implemented in OCaml and uses several C libraries 
through external bindings, most of them also developed within the 
\savonet{} project. The code contains approximatively $20$K lines of
OCaml code and $10$K lines of C code and runs on all major operating systems.
% , including Linux, Mac OSX and Windows.
The software along its documentation is freely
available\footnote{\url{http://savonet.sourceforge.net}} under an open-source
license.

One of the main goal which has motivated the design of the \liquidsoap{}
language is that it should be very accessible, even to non-programmers. It
turned out that having a functional programming language is very natural (\cf
Section~\ref{sec:transitions}). The built-in functions of the language often
have a large number of parameters, many of which have reasonable default values:
it would be very cumbersome to have to write them all each time, in the right
order. In order to address this, we have designed a new extension of
$\lambda$-calculus with labeled arguments and multi-abstractions which makes it
comfortable to use the scripting
API~\cite{baelde-mimram:webradio-lambda}. Having designed our own language also
allowed us to integrate a few domain-specific extensions, to display helpful
error messages and to generate a browsable documentation of the scripting API. In
practice, many of the users of \liquidsoap{} are motivated by creating a radio
and not very familiar with programming, so it can be considered that the design of
the language was a reasonable success from this point of view.

An other motivation was to ensure some safety properties of the stream
generation. A script in \liquidsoap{} describes a system that is intended to run
for months, some parts of whose rarely triggered, and it would be very
disappointing to notice a typo or a basic type error only after a particular
part of the code is used for an important event. In order to ensure essential
safety properties, the language is statically strongly typed. We want to put as
much static analysis as possible, as long as it doesn't put the burden on the
user, \ie{} all types should be inferred. As we shall see, \liquidsoap{} also
provides a few useful dynamic analysis.

\begin{figure}[t]
 \begin{center}
\[
\xymatrix{
  *+[F]{\mathtt{input.http}}\ar[r]&*+[F]{\mathtt{fallback}}\ar[r]&
  *+[F]{\mathtt{normalize}}\ar[r]&
  *+<10pt>[F=:<30pt>]{\mathtt{output.icecast}}\\
  *+[F]{\mathtt{playlist}}\ar[ur]&\\
}
\]
\end{center}
 \fcaption{A simple streaming system}
 \label{fig:simple}
 % Stream.png: 500x132 pixel, 91dpi, 14.03x3.70 cm, bb=0 0 398 105
\end{figure}

The current paper can be read without a prior understanding of the language and
its typing system, a detailed presentation can however be found
in~\cite{baelde-mimram:webradio-lambda}. We simply recall that the evaluation of
a \liquidsoap{} script triggers the construction of various sources, built from
various operators built into the language.
For example, the following script defines two elementary sources, respectively 
reading from an HTTP stream and a playlist of files, composed in a fallback 
(\ie{} if the HTTP stream is ended or broken then the playlist is used), 
filtered through a volume normalizer, and sent to an Icecast server which 
broadcasts the stream to the listeners:%\TODO{DB define icecast}
\begin{verbatim}
output.icecast(%vorbis,mount="myradio",
  normalize(fallback([input.http("http://other.net/radio"),
                      playlist("listing.txt")])))
\end{verbatim}
The graph underlying the system resulting from the execution of that script is
shown in Figure~\ref{fig:simple}. A few remarks on the syntax: the notation
\hbox{\texttt{[}\ldots\texttt{,}\ldots\texttt{]}} denotes a list, \texttt{mount}
is a label (the name of an argument of the function \texttt{output.icecast}) and
\texttt{\%vorbis} is a format parameter whose meaning is explained in
Section~\ref{sec:typing-ex}.

% \subsection{Fallibility}
% 
% \TODO{DB selon la place, on peut envisager de faire sauter cette section;
%   si on la laisse on peut la merger avec la précédente, en plus compact}
% 
% Finally, the information of whether or not a stream can be assumed to be
% infinite is also carried by the graph. For instance, if a source is created from
% a single file, one can try to decode it before starting streaming. If the file
% can be decoded, and one can assume that the file will not be deleted later, and
% then the source can be considered infallible. Later on, if this source is used,
% for instance in an operator that plays the first available source, then the
% source resulting of this operator is also infallible.  By induction over the
% vertices of the graph, each node can be considered fallible or not. Eventually,
% an infallible output can be considered as describing an infinite stream, while a
% fallible output describes a stream that may not be infinite.

\subsection{Efficient frames}
\TODO{DB In the JFLA paper we have a quick benchmark of the impact
  of changing the frame size from 1 to 100 to 1000.
  Also, can we still compete well with ices?}

An important aspect of the implementation is efficiency concerning both CPU and
memory usage. The streams manipulated can have high data rates (a typical video
stream needs 30Mo/s) and avoiding multiple copies of the data of the streams is
crucial. This is why we use a reference passing mechanism based on frames. A
\emph{frame} is a buffer of data of fixed duration that represents a portion of
the stream. In order to compute a stream, the active sources constantly create
frames and have them filled by passing references to them to their predecessor
sources, which in turn pass the references to their predecessors, and so on.
This passing by reference avoiding copies of data in memory.
% \TODO{DB at this point the reader doesn't see why several frames are needed}
% \TODO{RB I think it is ok now..}

This mechanism is refined in \liquidsoap{} in order to avoid computing twice the
same frame. For instance, one may want to have several outputs of the same
stream, \eg{} one to a server for broadcasting the stream and another one to a
local file for archiving purposes (the circled nodes in
Figure~\ref{fig:sharing}). In this case, the two outputs in the graph are
connected to the same source, and when those outputs transmit their frames to
this source to be filled, the operator should fill them with the same data. In
order to avoid computing the data twice, the first time that the source is asked
to fill a frame, it operates as described before. However, on the second time it
simply fills the frame with the data computed during the first call: computed
frames are \emph{cached} if necessary. \TODO{DB: What about the third time,
  fourth? When does it stop?  We need to talk about clock cycles to avoid
  confusing the reader.}  Once all the filling operations have been done, the
sources are informed that the stream has moved on to the next frame and can
forget their cache. The necessity for a source to cache its current frame is
detected when instantiating the stream generator.
% thus copying data in memory only when it is necessary.
\TODO{DB This paragraph doesn't say much; a little more could be said after
  transitions are evoked.}

\begin{figure}[t]
 \begin{center}
\[
\xymatrix{
  *+[F]{\mathtt{input.http}}\ar[r]&*+[F]{\mathtt{fallback}}\ar[r]&
  *+[F]{\mathtt{normalize}}\ar[r]\ar[dr]&
  *+<10pt>[F=:<30pt>]{\mathtt{output.icecast}}\\
  *+[F]{\mathtt{playlist}}\ar[ur]& & & *+<10pt>[F=:<30pt>]{\mathtt{output.file}}\\
}
\]
\end{center}
\fcaption{A streaming system with sharing}
\label{fig:sharing}
 % Stream.png: 500x132 pixel, 91dpi, 14.03x3.70 cm, bb=0 0 398 105
\end{figure}

\subsection{Functional transitions}
\label{sec:transitions}

\liquidsoap{} is a \emph{functional} programming language and a particularly
interesting application of this is the case of \textit{transitions} between
tracks, \ie{} how two consecutive tracks of a source should be chained: do we
want to mix a bit the two tracks in order to have a smooth transition? do we
want to add a jingle during the transition? etc. For example, a \emph{crossfade}
consists in mixing the end first track whose volume is faded out with the
beginning of second one whose volume is faded up (see Figure~\ref{fig:cross}).
\vspace{-5ex}
\begin{figure}[h]
 \begin{center}
\begin{tikzpicture}[xscale=0.8,yscale=0.8]
\draw[->] (0,0) -- (0,2.5);
\draw (-0.1,2) -- (0.1,2);
\draw (0,2) node[anchor=east]{100};
\draw (0,0) node[anchor=east]{0};
\draw[->] (0,0) -- (7.5,0);
\foreach \x in {1,2,3,4,5,6,7} \draw (\x,-0.1) -- (\x,0.1);
\draw (0,2.5) node[anchor=south]{volume (\%)};
\draw (7.5,0) node[anchor=west]{time (sec)};
\draw (0,2) -- (2,2) -- (5,0);
\draw (3,0) -- (5,2) -- (7.5,2);
\draw (1,2) node[anchor=south]{old};
\draw (6,2) node[anchor=south]{new};
\end{tikzpicture}
\end{center}
 \fcaption{A crossfade transition between two tracks}
 \label{fig:cross}
 % Stream.png: 500x132 pixel, 91dpi, 14.03x3.70 cm, bb=0 0 398 105
\end{figure}

In \liquidsoap{} the construction \texttt{fallback([$r$,$s$])} interactively
selects between two sources: it fills its frame using the source \texttt{$r$} if
it is available, or from the source \texttt{$s$} otherwise.  When switching from
one source to another, it is possible to specify a transition, which is given by
a function whose type is \hbox{\texttt{(source*source)->source}}, \ie{} a
function that takes the two sources as argument, the old and new source, and
return a new source, which gives the transition between them. Thus, the
following code defines a fallback source which performs a crossfade when
switching from one source to another:
\begin{verbatim}
 def crossfade(old,new) =
   add([fade.in(new), fade.out(old)])
 end
 f = fallback(transitions=[crossfade, crossfade], [r, s])
\end{verbatim}

Because any function can be used to define a transition, the possibilities
offered are numerous. For instance, the standard library (programmed in
\liquidsoap{}) defines the operator \texttt{smooth\_add}, which takes as
argument a main source (the tracks of a radio for instance) and a source of
jingles. When a new jingle is available, \texttt{smooth\_add} reduces the volume
of the main source, superposes the jingle to the current track, and increases
the volume of the main track back when the jingle is finished, producing a
dynamic jingle incrustation very easy to use and quite appreciated by
users.
% \footnote{Unfortunately, the code of this function would not fit in the
%   margin. It is available online at this address: \url{http://bit.ly/aHE0G0}}

\section{Heterogeneous stream contents}
\label{sec:content}

\input{hetero.tex}

Ideally, we would like to add some more properties to be statically checked by
typing. But it is sometimes difficult to adapt the type system while keeping
nice properties (type inference, principal types, etc.). For example,
\liquidsoap{} checks that active sources are \emph{infallible}, \ie{} always
have data available in their input stream, and this check is currently done by a
flow analysis and not typing. Another example is clocks which are described next
section.


\section{Clocks}
\label{sec:clocks}
\input{clocks.tex}

\section{Related work}

\liquidsoap{} is obviously different from classical tools
such as Ices or Darkice in
that it offers the user the freedom to assemble a stream
for a variety of operators, through a scripting
language rather than traditional configuration files.

\liquidsoap{} has more similarities with multimedia streaming libraries.
For example, GStreamer~\cite{gstreamer} defines a model of stream, and its API
can be used to define streaming systems in various programming
languages (primarily coded in C, the library has also been
ported to many other languages).
There are two differences, however:
the stream model that we use is more high-level than
GStreamer making it much simpler to compose operators, and moreover
our typing system brings many safety guarantees.

A last class of related tools is digital signal processing (DSP) languages.
An interesting system in this category is Faust~\cite{faust},
which provides a high-level functional programming language for
describing stream processing devices,
and compiles this language down to C++, which enables an integration
with various other systems.
Again, the traditional notion of stream in DSP is too weak for our
purpose, but this is only a shallow difference.
\liquidsoap{} does not build new operators but only assembles pre-defined
operators. In contrast, Faust compiles a single new operator at each
compilation, aggregating the basic operations used in the script
and optimizing their combination. It is also worth mentioning
Chuck~\cite{chuck}, a dynamic language with similar views.
\TODO{DB unlike faust, liquidsoap is interpreted}
It would be very interesting to interface \liquidsoap{} with such tools,
or import some of their techniques.
This could certainly be done with
DSP operators, and would allow us to program them efficiently from
the scripting language rather than in OCaml. Further, it should
be studied whether such an approach can be undertaken in general with
the kind of streaming system that we are considering.


\TODO{has been used in research~\cite{baccigalupo2007case,baccigalupo2007sharing}}
\TODO{on peut citer, je sais pas où, mais j'insisterais pas sur
  l'utilisation en recherche (c'est une utilisation comme une autre,
la recherche de claudio est indépendante de liq)}
\TODO{RB En même temps ça vaut quand même le coup de le mentioner. Par exemple
dans related work..}

\section{Conclusion}

Documentation, errors, user friendliness.
Requests.
Typing sources as objects whose methods are (telnet) services.

\TODO{SM 4 papiers ça fait vraiment très léger comme biblio, faudrait en rajouter}
\bibliographystyle{abbrv}
\bibliography{biblio}
\end{document}
