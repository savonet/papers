\documentclass{llncs}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{hyperref}

\pagestyle{plain}

\newcommand{\liquidsoap}{Liquidsoap}
\newcommand{\savonet}{Savonet}
% DB je retrouve pas de source claire pour l'italique pour les abbrev latines,
%   mais la virgule après i.e. et e.g. c'est clairement la règle
\newcommand{\eg}{{e.g.,}}
\newcommand{\ie}{{i.e.,}}
\newcommand{\cf}{{cf.~}}
\newcommand{\TODO}[1]{\marginpar{#1}}

\usepackage{graphicx}
\usepackage{xypic}

\usepackage{tikz}
\usetikzlibrary{snakes}

\title{\liquidsoap{}: \\
  a High-Level Programming~Language \\
  for Multimedia~Streaming}
\author{David Baelde\inst{1} \and Romain Beauxis\inst{2} \and Samuel Mimram\inst{3}}
\institute{
  University of Minnesota, USA
  \and
  Tulane University, USA
  \and
  CEA LIST -- LMeASI, France
}

\hypersetup{
  pdftitle={\csname @title\endcsname},
  pdfauthor={David Baelde, Romain Beauxis and Samuel Mimram},
  unicode=true,
  colorlinks=true,
  linkcolor=black,
  citecolor=black,
  urlcolor=black
}

\begin{document}
\maketitle

\begin{abstract}
Programming languages offer natural and flexible ways to describe various
systems. A good language makes it easy to describe simple configurations but,
unlike other approaches based on configuration files or static graphical
interfaces, it also allows the user to build complex and highly customized systems.
We present \liquidsoap, a high-level functional programming
language for generating, manipulating and broadcasting multimedia streams. We
describe a model that supports a rich collection of operators (track scheduling,
jingle insertion, mix, metadata updates, various transitions), and some aspects
of language design that make it adapted to the application domain.
\end{abstract}

% DB: j'en ferais moins, par contre je renforcerais la
%  conclusion:
%   While software implementations can offer much more flexibility,
%   many applications have arbitrary limitations. It is often thought
%   that this is necessary for the simplicity of use. With liquidsoap,
%   we seek a better compromise, following Alan Kay's commandment:
%   ``simple things should be simple, complex things should be possible''.
The widespread adoption of broadband internet in the last decades has
changed a lot our way of generating and transmitting information. Classical
devices from the analog era, such as television or radio broadcasting devices
have been rapidly adapted to the digital world in order to benefit from the new
technologies available. Whilst analog devices were mostly based on hardware
implementations, their digital counterpart often consists in software
implementations,
% , \eg{} hardware
% PBX for phone communications being replaced by software like Asterisk and IP
% phones.
which potentially offers much more flexibility and modularity in their design.
% and allow updates, both for bugfix and new features, at virtually no cost.
% In this context of improvements, updates and enhancements of old technologies,
% we are here specifically interested in adapting audio and video broadcasting
% techniques to the digital world.
% So, creating and broadcasting a stream of multimedia data with recent computers
% has become technically very easy.
However, we believe that the current software technologies to perform such tasks
have not yet fully brought the new ideas which are necessary in order to really
benefit from the new possibilities offered by modern computing devices.

We are specifically interested here in the generation of multimedia streams
(containing audio or video). For example, many webradios are continuously
broadcasting audio data streams, and people can connect to these in order to
listen to the radios. At first, generating the streams might seem really simple:
it is just a bunch of concatenated audio files. However, in practice the needs
of real-world radios are much higher than this, and designing a generator for
multimedia streams needs a lot of flexibility in order to be able to cope with
most of the expectations and requirements of users. For instance, a radio stream
may have jingles announcing next coming shows or commercials. It may also play
those jingles at a regular interval of time, between songs or on top of
them. Also, a radio program may be composed of automatic playlist for a certain
period, \eg{} during the night, and live shows during the day. Similarly, one
may want to control and process the data before broadcasting it to the public,
performing tasks like volume normalization, cross-fading between tracks
(possibly parameterized by the respective volumes of the old and new tracks or
predefined settings), blanks removal (nobody wants to listen to silence),
etc. Moreover, the generation of the stream should be rock-solid: most webradios
are broadcasting automatically 24/7 and don't want to have to manually restart
the generator if it crashes after a few hours or a few days.

Those examples, among many others, show the need for very flexible and modular
solutions for creating and broadcasting multimedia data. Most of the currently
available tools to broadcast multimedia data over the Internet (such as Darkice,
Ezstream, VideoLAN, Rivendell or SAM Broadcaster) consist of straightforward
adaptation of classical streaming technologies, based on
predefined interfaces, such as a virtual mixing console or static file-based
setups. Those tools, although quite powerful, are usually very hard to adapt to
a particular need and are more and more often perceived as limited by the very
% DB "new" c'est abusé
constrained design of the program. Here, we present a new methodology for
achieving the task based on a dedicated \emph{programming language} called
\emph{Liquidsoap}, which brings much more flexibility and has proved in practice
to be adapted to the needs of a wide variety of users' requirements.

Programming languages are a particularly important aspect of modern software
% DB definition d'applicatif = fonctionel en gros, pas domain-specific
technologies.  Whether general or applicative, programming languages are often
the right tool to release creativity and flexibility for creating new software
applications.  They have been used in various practical contexts to bring
flexibility and overcome static pre-defined paradigms. One may, for instance,
think of Perl, invented to allow powerful and flexible word-based treatments, or
PHP, which allows to easily create dynamic web pages. We believe that a good
programming language should follow three fundamental principles: it should be
\begin{enumerate}
\item \emph{adapted}: users should be able to perform, most of the tasks in the
  domain of application of the language (generating multimedia streams in our
  case);
\item \emph{simple}: users should be able to perform the tasks in a simple way
  (this means that it should be reasonably concise, but also reasonably
  understandable -- keep in mind that people willing to generate webradios are
  far from being all good programmers);
\item \emph{safe}: the compiler should perform checks to avoid as many bugs as
  possible (a stream generator has for example to ensure that there will always
  be data to stream).
\end{enumerate}

% DB le paragraphe suivant est principalement redondant

The motivation behind the language presented in this article was to bring
ideas and technologies from programming languages to the domain of multimedia
broadcasting. It originated after realizing that the existing tools for digital
broadcasting where not expressive enough to fit the authors' needs. In order to
overcome those shortcomings, an applied language was developed which
%, as for Perl and PHP,
includes first-class notions of streams, as well as dedicated operators to
create them, combine them and modify them. The resulting possibilities for
designing and creating multimedia streams are very broad and allow creative
innovations, but although the language is intended to be powerful, it is also
relatively easy to use, even by people not very familiar with programming.

% Another important aspect of this application is its potential users. Multimedia
% stream designers are not often programming language specialists. Moreover,
% creating an Internet radio should not require advanced programming skills.  For
% there reasons, although the language is intended to be powerful, it should also
% be relatively easy to use, at least for building a basic stream.

\section{\liquidsoap}

\emph{Now that related works is with the conclusion, this section doesn't say 
much and should be moved in other places (a little bit in the introduction,
other bits in other places)}

The tool \liquidsoap\ \cite{liquidsoap} is in two parts:
  a model of streams which allows the definition of enough
  operators on streams, and a functional programming language
  (called \liquidsoap, or the script language) which enables
  the user to describe its streaming setup by composing those operators.

The \liquidsoap\ language is interpreted.
The evaluation of a script or expression triggers the construction
of a stream processing devices, built by composing various elementary
blocks.
These devices are then initialized and perform their streaming task:
decoding files, processing and communicating data, etc.

% TODO the prog language is interpreted..
%  this is important when comparing with faust

Although the language \liquidsoap\ borrows from other programming
languages, it is unique to our tool.
There are several reasons for having created our own language.
First, we felt that a static type discipline would be useful:
A script describes a system that is intended to run for days,
even month, with some parts rarely triggered.
It would be very disappointing to notice a typo or basic type
error only after two weeks of running, precisely at the time
of a special show.
Hence, we want to put as much static analysis as possible,
as long as it doesn't put the burden on the user,
\ie\ all types should be infered.
There is not so much choice of static languages than can be
easily embedded and are user-friendly.
Designing our own simple functional programming language,
and tightly integrating with the rest of the tool,
provides a good documentation and helpful error messages.
Moreover, having our own language allowed us to design
a few domain-specific type extensions.


\section{Streaming model}
\label{sec:model}

A stream can be understood as a timed sequence of data.
In digital signal processing, it will simply be an infinite sequence of 
samples | floating point values for audio, images for video.
However, multimedia streaming also involves high-level notions such
as metadata and tracks, and many useful operations rely on it.

% use env{definition} ? of course, it's informal
In liquidsoap, a \emph{stream} is a succession of \emph{tracks},
which can be thought of as individual songs on a musical radio show.
A track might be finite or infinite.
It can contain any combination of audio, video and MIDI \emph{channels},
which we discuss more in Section~\ref{sec:content}.
Finally, any instant in a track can have metadata,
consisting of a list of fields associated to (string) values.

\TODO{Do we allow fallible streams or fallible sources?
  Is there a hole of a certain duration between tracks in a stream,
  or just a failure to produce by the source.
  I think it's the latter but I'm not sure.}

% TODO DB this drawing (by me) doesn't look very good and doesn't bring much
\begin{figure}[htn]
 \begin{center}
\includegraphics{stream}
\end{center}
 \caption{A \liquidsoap{} stream}
 % Stream.png: 500x132 pixel, 91dpi, 14.03x3.70 cm, bb=0 0 398 105
\end{figure}

Being infinite objects,
streams are not represented directly but generated on the fly.
Anyway, they are meant to be produced interactively, depending on various
external factors.
In liquidsoap, a stream generator is called a \emph{source}.
Some sources purely produce a stream, getting it from an external device
(\eg\ file, sound card, network) or synthesizing it.
Many other sources actually produce a stream based on input streams
for other sources.
This gives rise to a directed acylic graph whose vertices are sources
and edges are dependencies.

% Given an acyclic graph describing a stream generator, the roots of the graph are the operator that create 
% the initial streams, called \textit{sources}. Those sources can be created from a single file, a playlist, an HTTP input,
% the sound card, etc. The sources are then modified and composed with each other using 
% \textit{operators} that, for instance, play a source if it is available or a second one otherwise, or modify
% the metadata, mix the audio data of two sources, etc.
% Finally, the leaves of the graph describe the \textit{outputs} of the stream. Those outputs consist, for instance,
%% DB first occurrence of icecast, never introduced
% of playing the stream on the local sound card, saving it to a file or sending it to and Icecast server. 
% For this initial description, we suppose that the graph has only one output.

\TODO{What exactly do we mean by operator? In practice we use it for any
  function building a source, whether it has source arguments or not.}

A important type of source is \emph{active} ones,
which not only compute a stream like any other source,
but also perform some observable task, typically outputting its stream
somewhere.
Sources produce streams in small chunks called \emph{frames}.
Streaming is performed top-down:
only active sources actively attempt to produce their stream,
pulling data from their input sources as needed,
which pull data from dependent sources, and so on.
% DB en fait parler de frames est pe trop précis: on omet de dire
% qu'on remplit un break à la fois, ce qui correspond au paragraphe
% suivant

Two important aspects of sources is that
(1) they do not constantly stream:
the stream corresponding to an unused stream is frozen in time,
and
(2) they are allow to fail, \ie\ deny streaming, at the end of a track.
% DB faudrait se documenter mais je crois que c'est vraiment particulier:
%   ça nous distingue du DSP mais pe aussi gstreamer

This last ingredient is crucial to obtain the expected collection of operators.
For example, a rotation operator will play alternatively several sources,
but should only rotate at the end of tracks,
and its unused sources should not keep going -- otherwise we might find them
in the middle of a track when we come back to playing them.
Also, we need to be able to insert a jingles in between two tracks of a 
stream, which involves momentarily stopping it.

% TODO DB J'ai pas parlé de cycles (clocks)
%   mais on peut pe pas completement éviter
%   qd je parle de stopper un flux c'est bien par rapport a une notion de 
%   temps...

\begin{figure}[htn]
 \begin{center}
\[
\xymatrix{
  *+[F]{\mathtt{input.http}}\ar[r]&*+[F]{\mathtt{fallback}}\ar[r]&
  *+[F]{\mathtt{normalize}}\ar[r]&
  *+[F]{\mathtt{output.icecast}}\\
  *+[F]{\mathtt{playlist}}\ar[ur]&\\
}
\]
\end{center}
 \caption{A stream generator} \label{fig:simple}
 % Stream.png: 500x132 pixel, 91dpi, 14.03x3.70 cm, bb=0 0 398 105
\end{figure}

Having introduced all the terminology, we can finally give an example of 
\liquidsoap\ setup, in Figure~\ref{fig:simple}.
Here, we have two elementary sources, respectively reading from an HTTP stream 
and a playlist of files, composed in a fallback, filtered through a volume
normalizer and sent to an Icecast server for broadcast. % TODO DB first occurrence of icecast
Such a graph is the skeleton of the following \liquidsoap\ script:
\begin{verbatim}
output.icecast(%vorbis,"myradio",
  normalize(fallback([input.http("http://other.net/radio"),
                      playlist("listing.txt")])))
\end{verbatim}
The script provides several other details, such as the encoding format 
(Vorbis) and the names of the Icecast radio, the input HTTP stream
and the playlist file.

\subsection{Sharing}

\emph{The idea of this section\ldots
having done the minimum to define the high-level terminology before,
we now turn to more technical details?
Efficiency issues, sharing.}

Using this method, the stream can be described using a finite amount of memory. In fact, the frames used
to generate the stream are statically allocated and passed as memory pointers during the generation, which 
avoids copying data in memory.
% TODO DB at this point the reader doesn't see why several frames are needed

The description of a stream generator in the previous section is simple and 
natural. Unfortunately, most of the time it is too limited. For instance, one 
may want to have several outputs of the same 
stream, \eg\ one to a local file for archiving purposes and another one to an Icecast server to be
broadcasted.
In this case, the two outputs in the graph are connected to the same operator. Hence, when those output
transmit their frame to this operator to be filled, the operator should fill them with the same data.

\begin{figure}[htn]
 \begin{center}
\[
\xymatrix{
  *+[F]{\mathtt{input.http}}\ar[r]&*+[F]{\mathtt{fallback}}\ar[r]&
  *+[F]{\mathtt{normalize}}\ar[r]\ar[dr]&
  *+[F]{\mathtt{output.icecast}}\\
  *+[F]{\mathtt{playlist}}\ar[ur]& & & *+[F]{\mathtt{output.file}}\\
}
\]
\end{center}
 \caption{A stream generator with sharing}
 % Stream.png: 500x132 pixel, 91dpi, 14.03x3.70 cm, bb=0 0 398 105
\end{figure}


For this reason, the first time that the operator is asked to fill the frame, it should pass it to its 
underlying operators, as described before. However, the second time, it should just fill the frame 
with the data gathered during the first call, which implies \textit{caching} the data obtained during the first call.

Therefore, even though the initial stream generator model could avoid copying data in memory, there 
are situations where it is not possible. In order to deal with these situations, the 
model carries a notion of \textit{ticks}. Ticks represent an elementary unit of time
for stream generation. Each frame contains a fixed number of ticks and the stream is split
in bunches of ticks representing each frame. During the same bunch of ticks, when filling a frame, the nodes only 
transmit their frame to their underlying nodes once and, for the successive calls, use a cache of this data. 
Once all the filling operations have been done for a bunch of ticks, the nodes are informed that the 
stream has moved to the next bunch and reset their cached values. 

Finally, the necessity for a node to cache its current frame is detected when instantiating the graph, thus
copying data in memory only when it is necessary.

\subsection{...}

Could be a good place to talk about how liquidsoap runs: parsing, type 
checking, building sources, performing dynamic analysis (only fallibility for 
now) and finally initializing them for streaming.

% TODO DB "infallible", and introduce the phases, "static/dynamic analysis"
Finally, the information of whether or not a stream can be assumed to be infinite is also carried by the 
graph. For instance, if a source is created from a single file, one can try to decode it before starting 
streaming. If the file can be decoded, and one can assume that the file will not be deleted later, and then 
the source can be considered infallible. Later on, if this source is used, for instance in an operator that plays 
the first available source, then the source resulting of this operator is also infallible.
By induction over the vertices of the graph, each node can be considered fallible or not. Eventually,
an infallible output can be considered as describing an infinite stream, while a fallible
output describes a stream that may not be infinite.

\subsection{Transitions}

Now, the language penetrates the model, and functions are not syntactic sugar.

Smooth add can be presented at this point,
illustrating well how the langage can build non-trivial operators from
our simple building blocks.

\section{Heterogeneous stream contents} \label{sec:content}

Motivate why we need it (it's not only about video and MIDI)
and how we make sure it's consistent.

Fixed/variable arity, content kind, type, non-parametricity, inference.

\section{Clocks}

\emph{Slogan: clocks are an abstraction of threads?
  It's easier to manipulate, users can't make mistakes\ldots almost.
  We currently don't say anything about the (high-level) implementation.
  We can re-use most of the documentation on clocks here,
  notably illustrating the use of internal and external clocks.}

% <MOVED> DB The following has been moved from earlier sections

The timing, or clock, associated to a multimedia stream can be real-time, if the stream is created 
% DB scaled?
or broadcasted live, or any scaled timing, for instance if the stream consists of files. \textit{A priori},
describing and broadcasting a stream implies real-time output. As we see later, this is unfortunately 
not sufficient for complex settings.
% TODO DB infinite <> infallible
Also, a stream can be finite or infinite. Infinite streams are particularly interesting for broadcasting
because most of the time, we expect a radio, for instance, to be always online. However, this needs 
a special care since it implies some assumption about the validity of the elements that build the stream.

% TODO DB the following should move later
Also, the stream generator can be used at any rate. For instance,
for a live broadcast, the generator will be asked to fill frames at real rate, while 
for a stream saved to a file, the generator will be asked to fill frames at the maximal possible rate.
% DB in the following, confusion between transition and crossing

% </MOVED> DB 

Another limitation of the current model is the possibility to describe advanced transitions in 
the stream. For instance, one may want to use a crossfade between two tracks 
of the stream, \ie{}
fade out the volume of an ending track, fade in the volume of a starting track and merge this together.

\begin{figure}[htn]
 \begin{center}
\begin{tikzpicture}[xscale=0.8,yscale=0.8]
\draw[->] (0,0) -- (0,2.5);
\draw (-0.1,2) -- (0.1,2);
\draw (0,2) node[anchor=east]{100};
\draw (0,0) node[anchor=east]{0};
\draw[->] (0,0) -- (7.5,0);
\foreach \x in {1,2,3,4,5,6,7} \draw (\x,-0.1) -- (\x,0.1);
\draw (0,2.5) node[anchor=south]{volume (\%)};
\draw (7.5,0) node[anchor=west]{time (sec)};
\draw (0,2) -- (2,2) -- (5,0);
\draw (3,0) -- (5,2) -- (7.5,2);
\draw (1,2) node[anchor=south]{track $n$};
\draw (6,2) node[anchor=south]{track $n+1$};
\end{tikzpicture}
\end{center}
 \caption{A crossfade transition between two tracks}
 \label{cross-fig}
 % Stream.png: 500x132 pixel, 91dpi, 14.03x3.70 cm, bb=0 0 398 105
\end{figure}

The initial source can be created, for instance, with a playlist of files. Then,
a \texttt{crossfade} operator would take this source and return a source whose tracks are 
crossfaded as shown in Figure \ref{cross-fig}. In order to do this, the operators has to 
detect sufficiently in advance the end of the current track, collect the data of the
end of the track, collect the data of the beginning of the next track, apply the respective
fade out and fade in and add the two streams to create the transition.

However, in this case we need to introduce a new notion in the model. Without transitions, the 
source generator can be used with a uniform rate on all nodes: frames are filled
at the same rate on every node. Unfortunately, the \texttt{crossfade} operator
does not have this property: when it detects the end of a track, it will query many frames in advance 
to the underlying source in order to compute the crossfade. This behaviour breaks the uniformity of 
timing in the graph and requires to introduce \textit{multiple clocks}.


\begin{figure}[htn]
 \begin{center}
\[
\def\f{\save
*+<15pt>[F--]\frm{}\ar @{--} "2,2"\restore}%
\def\g{\save
"2,4"."1,2"."1,5"!C*+<27pt>[F--]\frm{}\ar @{--} "1,1"\restore}%
\xymatrix{
   \mathtt{clock_1} & *+[F]{\mathtt{playlist}}\ar[r]\f&*+[F]{\mathtt{crossfade}}\ar[r]&  *+[F]{\mathtt{fallback}}\ar[r]&
  *+[F]{\mathtt{output.icecast}}\\
   &\mathtt{clock_2} &  & *+[F]{\mathtt{jingles}}\ar[u]\g& 
}
\]
\end{center}
 \caption{A stream generator with different clocks}
 % Stream.png: 500x132 pixel, 91dpi, 14.03x3.70 cm, bb=0 0 398 105
\end{figure}

Clocks are represented in the model by a notion of locality in the graph. The graph is then partitioned into 
different sets, where each set shares the same clock.
When instantiating the graph, each operator declares if it needs a custom clock for him or its sources. 
Then, when initializing the graph of the stream generator, the clocks are attributed by a constraint 
satisfaction algorithm. Because of caching, we do not want a source to be connected to two different operators with 
two different clocks. In this case, this is detected when instantiating the graph and an error is raised.
Similarly, some sources do not support clocks whose rate is different than real time, for instance input 
from the local sound card. In this case too, if the clock attached to the source is not real time, an error
is raised.

\section{Related works}

\liquidsoap\ is obviously different from tools such as Ices or Darkice in
that it offers the user the freedom to assemble a stream
for a vast variety of operators, through a scripting
language rather than more traditional configuration languages.

Liquidsoap has similarities with multimedia streaming libraries.
For example, GStreamer defines a model of stream, and its API
can be used to define streaming systems in various programming
languages (primarily coded in C, the library has also been
ported to many other languages).
There are two differences, however.
First, the stream model that we use is more high-level than
GStreamer. % TODO check
Second and more importantly,
our programming language makes it much simpler
to compose operators; all the low level aspects are hidden
from the user.
% TODO nécessite plus de détails, mais je pense aux clocks, au sharing
%   etc

A last class of related tools is digital signal processing (DSP) languages.
An interesting system in this category is Faust~\cite{faust},
which provides a high-level functional programming language for
describing stream processing devices,
and compiles this language down to C++, which enables an integration
with various other systems.
Again, the traditional notion of stream in DSP is too weak for our
purpose, but this is only a shallow difference.
Liquidsoap does not build new operators but only assembles pre-defined
operators. In contrast, Faust compiles a single new operator at each
compilation, aggregating the basic operations used in the script
and optimizing their combination.
It would be very interesting to interface \liquidsoap\ with such a tool,
or import some of their techniques. This could certainly be done with
DSP operators, and would allow us to program them efficiently from
the scripting language rather than in OCaml. Further, it should
be studied whether such an approach can be undertaken in general with
the kind of streaming system that we are considering.


TODO: has been used in research~\cite{baccigalupo2007case,baccigalupo2007sharing}
%   on peut citer, je sais pas où, mais j'insisterais pas sur
%   l'utilisation en recherche (c'est une utilisation comme une autre,
% la recherche de claudio est indépendante de liq)

In the following, we describe the streaming model used in liquidsoap.
The richness of that model induces some non-trivial correctness conditions,
and we describe how the programming language helps to avoid such
problems.
We do not provide a full formal description of the language and its
type system: this has been done to some extent in 
\cite{baelde-mimram:webradio-lambda}, and we prefer to focus on the
high-level functioning of \liquidsoap\ in this paper.

\section{Conclusion}

Documentation, errors, user friendliness.
Requests.

\bibliographystyle{abbrv}
\bibliography{biblio}
\end{document}
