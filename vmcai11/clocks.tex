
Until now, we have only described streaming systems where there is
a unique, global clock. In such systems, time flows at the same rate
for all sources.
% DB I think "wallclock time" is better than "real time" which has 
%    other connotations
By default, this rate corresponds to the wallclock time,
which is appropriate for a live broadcast,
but it may also be different.
For example, when producing a file, one might want the time rate
to be as fast as the CPU allows.

While having a global clock suffices in many situations,
there are a couple of reasons why a streaming system might involve multiple
clocks or time flows.
The first reason is external to liquidsoap: there is simply
not a unique notion of time in the real world.
A computer's internal clock indicates a slightly different time
than your watch or another computer's clock.
Moreover, when communicating with a remote computer, network
latency causes a perceived time distortion.
Even within a single computer there are several clocks: notably, each
soundcard has its own clock, which will tick at a slightly different
rate than the main clock of the computer.
Since liquidsoap communicates with soundcards and remote computers,
it has to take those mismatches into account.

There are also some reasons that are purely internal to liquidsoap:
in order to produce a stream at a given speed,
a source might need to obtain data from another source at
a different rate. This is obvious for an operator that speeds up or
slows down audio, but is also needed in more subtle cases
such as a crossfading operator.
Crossfading consists in fading the volume of a stream around tracks
limits, which is not problematic, and more crucially combining a portion
of the end of a track with the beginning of the next one\footnote{
  In \liquidsoap, crossfading derives from a simpler operator that
  only takes care of crossing, \ie\ combining the end of a track
  with the beginning of the next one. The \texttt{cross} operator
  takes a transition function as a parameter for describing how
  the two tracks are actually combined.
}.
The result is close to what was represented in Figure~\ref{cross-fig}
except that the two tracks originate from the same source.
During the lapse of time where the operator combines
data from an end of track with the beginning of the other other,
the crossing operator needs twice as much stream data\footnote{
  % Note that there is no need to store the beginning of track
  % (this is only done in smart_cross for computing its volume)
  In the actual implementation, we have to
  maintain a copy of a section of the past content
  of the input stream until the end of a track,
  generally using remaining time estimations to avoid maintaining
  this sliding window all the time.
  The time acceleration does not actually happen
  when the tracks are combined but when the sliding window
  is initially filled up.
}.
After ten tracks,
with a crossing duration of six seconds, one more minute will have
passed for the source compared to the time of the crossing operator.

In order to avoid inconsistencies caused by time differences,
while maintaining a simple and efficient execution model for
its sources, liquidsoap works under the restriction that
one source belongs to a unique clock,
fixed once for all when the source is created.
Sources from different clocks cannot communicate using the normal
streaming protocol, since it is organized around clock cycles.

In the graphical representation of streaming systems,
clocks induce a partition of sources represented by a notion of locality
or box.
For example, the graph shown in Figure~\ref{fig:boxes}
corresponds to the stream generators built in the following
script:
\begin{verbatim}
output.icecast(%vorbis,mount="myradio",
  fallback([crossfade(playlist("some.txt")),
            jingles]))
\end{verbatim}

\begin{figure}[htpb]
 \begin{center}
\[
\def\f{\save
*+<15pt>[F--]\frm{}\ar @{--} "2,2"\restore}%
\def\g{\save
"2,4"."1,2"."1,5"!C*+<27pt>[F--]\frm{}\ar @{--} "1,1"\restore}%
\xymatrix{
   \mathtt{clock_1} & *+[F]{\mathtt{playlist}}\ar[r]\f&*+[F]{\mathtt{crossfade}}\ar[r]&  *+[F]{\mathtt{fallback}}\ar[r]&
  *+[F]{\mathtt{output.icecast}}\\
   &\mathtt{clock_2} &  & *+[F]{\mathtt{jingles}}\ar[u]\g& 
}
\]
\end{center}
 \caption{A stream generator with different clocks}
 \label{fig:boxes}
 % Stream.png: 500x132 pixel, 91dpi, 14.03x3.70 cm, bb=0 0 398 105
\end{figure}

There, $\verb.clock._{\tiny{\verb.2.}}$ was created specifically for the crossfading
operator; the rate of that clock is controlled by that operator,
which can hence accelerate it around track changes without any
risk of inconsistency.
The other clock is simply a wallclock, so that the main stream
is produced following the real (wallclock) time rate.

Each clock is in charge of animating its own active sources.
Some clocks may not run all the time. In the above example,
the crossfading's clock is not ticking when the fallback
is playing jingles.
But most clocks do run their sources all the time.
\TODO{DB: being active has nothing to do with clock nesting\ldots
  but I don't know what nesting is about!}
It is the case of wallclocks or clocks corresponding to
soundcards.
From an implementation viewpoint, each of those clocks launches
its own thread.
Hence, clocks provide a way to split the generation of one or
several streams accross several threads,
and hence multiple CPU cores\TODO{DB it's even true with OCaml}.
This powerful possibility is made available to the user
through the abstract notion of clock.
As we shall see in the next section,
the script writer never needs to specify clocks unless he
explicitly wants a particular setup,
and \liquidsoap\ automatically checks that clock assignements
are correct.
\TODO{DB: by "correct" I mean that the user cannot break the
  streaming protocol by assigning wrong clocks, and so does
  not get unexpected behaviors (although this is only a fuzzy claim)}

\TODO{DB: should we show the nice example from the doc where icecast
  does not interfere with a file backup and a sound card input?
  Perhaps just mention it above, but some code could be nice.}

\subsection{Clock assignment}

Clocks are not represented in the type of \liquidsoap\ sources.
Although it would be nice to statically check clock assignment,
type inference would not be possible without technical annotations
from the user.

Instead, clocks are assigned upon source creation.
Some sources require to belong to a particular, definite clock,
such as the wallclock, or the clock corresponding to a sound card.
Other sources simply require that their clock is the same as their
input sources.
Since clocks often cannot be inferred bottom-up, we use a notion
of clock variable that can be left undefined.
After this phase, remaining unknown clocks are forcibly assigned
to the default wallclock, and new sources are started by their
respective clocks.

Two errors: two different definite clocks, nested clocks
