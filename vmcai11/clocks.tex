
Until now, we have only described streaming systems where there is
a unique, global clock. In such systems, time flows at the same rate
for all sources.
% DB I think "wallclock time" is better than "real time" which has 
%    other connotations
By default, this rate corresponds to the wallclock time,
which is appropriate for a live broadcast,
but it does not need to be so.
For example, when producing a file from other files,
one might want the time rate to be as fast as the CPU allows.

\subsection{Motivation}

While having a global clock suffices in many situations,
there are a couple of reasons why a streaming system might involve multiple
clocks or time flows.
The first reason is external to liquidsoap: there is simply
not a unique notion of time in the real world.
A computer's internal clock indicates a slightly different time
than your watch or another computer's clock.
Moreover, when communicating with a remote computer, network
latency causes a perceived time distortion.
Even within a single computer there are several clocks: notably, each
soundcard has its own clock, which will tick at a slightly different
rate than the main clock of the computer.
Since liquidsoap communicates with soundcards and remote computers,
it has to take those mismatches into account.

There are also some reasons that are purely internal to liquidsoap:
in order to produce a stream at a given speed,
a source might need to obtain data from another source at
a different rate. This is obvious for an operator that speeds up or
slows down audio, but is also needed in more subtle cases
such as a crossfading operator.
\TODO{SM on devrait déjà avoir expliqué le crossfading avant}
Crossfading consists in fading the volume of a stream around tracks
limits, which is not problematic, and more crucially combining a portion
of the end of a track with the beginning of the next one\footnote{
  In \liquidsoap, crossfading derives from a simpler operator that
  only takes care of crossing, \ie\ combining the end of a track
  with the beginning of the next one. The \texttt{cross} operator
  takes a transition function as a parameter for describing how
  the two tracks are actually combined.
}.
\TODO{SM 1. c'est pas joli les notes 2. est ce que celle-ci n'est pas trop du détail ?}
The result is close to what was represented in Figure~\ref{cross-fig}
except that the two tracks originate from the same source.
During the lapse of time where the operator combines
data from an end of track with the beginning of the other other,
the crossing operator needs twice as much stream data\footnote{
  % Note that there is no need to store the beginning of track
  % (this is only done in smart_cross for computing its volume)
  In the actual implementation, we have to
  maintain a copy of a section of the past content
  of the input stream until the end of a track,
  generally using remaining time estimations to avoid maintaining
  this sliding window all the time.
  The time acceleration does not actually happen
  when the tracks are combined but when the sliding window
  is initially filled up.
}.
\TODO{SM pareil, c'est trop implém}
After ten tracks,
with a crossing duration of six seconds, one more minute will have
passed for the source compared to the time of the crossing operator.

\subsection{Model}

In order to avoid inconsistencies caused by time differences,
while maintaining a simple and efficient execution model for
its sources, liquidsoap works under the restriction that
one source belongs to a unique clock,
fixed once for all when the source is created.
Sources from different clocks cannot communicate using the normal
streaming protocol, since it is organized around clock cycles.
Each clock is responsible for animating its own active sources
and has full control on how it does it.

In the graphical representation of streaming systems,
clocks induce a partition of sources represented by a notion of locality
or box, and clock dependencies are represented by nesting.
For example, the graph shown in Figure~\ref{fig:boxes}
corresponds to the stream generators built in the following
script:
\begin{verbatim}
output.icecast(%vorbis,mount="myradio",
  fallback([crossfade(playlist("some.txt")),jingles]))
\end{verbatim}

\begin{figure}[t]
 \begin{center}
\[
\def\f{\save
*+<15pt>[F--]\frm{}\ar @{--} "2,2"\restore}%
\def\g{\save
"2,4"."1,2"."1,5"!C*+<27pt>[F--]\frm{}\ar @{--} "1,1"\restore}%
\xymatrix{
   \mathtt{clock_1} & *+[F]{\mathtt{playlist}}\ar[r]\f&*+[F]{\mathtt{crossfade}}\ar[r]&  *+[F]{\mathtt{fallback}}\ar[r]&
  *+[F]{\mathtt{output.icecast}}\\
   &\mathtt{clock_2} &  & *+[F]{\mathtt{jingles}}\ar[u]\g& 
}
\]
\end{center}
 \caption{A streaming system with two clocks}
 \label{fig:boxes}
 % Stream.png: 500x132 pixel, 91dpi, 14.03x3.70 cm, bb=0 0 398 105
\end{figure}

There, $\verb.clock._{\tiny{\verb.2.}}$
was created specifically for the crossfading
operator; the rate of that clock is controlled by that operator,
which can hence accelerate it around track changes without any
risk of inconsistency.
The other clock is simply a wallclock, so that the main stream
is produced following the real (wallclock) time rate.

A clock is said to be active if it ticks by itself,
therefore running its sources constantly.
It is the case of wallclocks or soundcard clocks.
We say that a clock depends on another one
if its animation (and thus time rate) depends on it.
% DB: I wanted to write this since it holds geometrically for nesting
%   "It is not possible for a clock to depend (directly) on several others."
%   but it doesn't seem forced by anything,
%   and in fact the implementation should allow it
Active sources do not depend on other sources,
and dependencies must be acyclic.
In the above example, the ticking of
$\verb.clock._{\tiny{\verb.2.}}$ is provoked by that of
$\verb.clock._{\tiny{\verb.1.}}$, and freezes when the fallback
is playing jingles.
% a clock $c'$ might depend on $c$ if it ticks twice as fast;
% such a clock will be used in the implementation of a speed doubling
% operator.
Although nothing forces it in the model, it makes more sense if
each passive source depends (possibly indirectly) on an active one,
and all sources without dependencies are active.
Those assumptions are in fact guaranteed to hold for the systems
built from the \liquidsoap\ language.
% this is because the user only creates wallclocks
% and the only dependent clocks are suitably nested (cross and stretch)

From an implementation viewpoint, each active clock launches
its own streaming thread.
Hence, clocks provide a way to split the generation of one or
several streams accross several threads,
and hence multiple CPU cores\footnote{
  Although OCaml uses a global memory management lock that makes it
  impossible for two OCaml threads to run concurrently, there is no
  such constraint when a thread runs a foreign function.
  This allows us to avoid the limitation since
  most of the computation in \liquidsoap\ takes place in decoding
  and encoding multimedia formats, which is done by C libraries.
}.
This powerful possibility is made available to the user
through the intuitive notion of clock.
As we shall see in the next section,
the script writer never needs to specify clocks unless he
explicitly wants a particular setup,
and \liquidsoap\ automatically checks that clock assignements
are correct.

\TODO{DB: should we show the nice example from the doc where icecast
  does not interfere with a file backup and a sound card input?
  Perhaps just mention it above, but some code could be nice.}

\subsection{Clock assignment}

Clocks are not represented in the type of \liquidsoap\ sources.
Although it would be nice to statically check clock assignment,
type inference would not be possible without technical annotations
from the user.

Instead, clocks are assigned upon source creation.
Some sources require to belong to a particular, definite clock,
such as the wallclock, or the clock corresponding to a sound card.
Most sources simply require that their clock is the same as their
input sources.
Since clocks often cannot be inferred bottom-up, we use a notion
of clock variable that can be left undefined.
Clock variables reflect the required clock dependencies,
which are maintained during the inference process.

Two errors can occur during this phase.
Although they are runtime errors that could be raised
in the middle of streaming when new sources are created
(\eg\ by means of a transition),
this usually only happens during the initial construction.
The first error is raised when
two different known clocks need to be unified.
For example, in the following script, the ALSA input is
required to belong to the ALSA clock and \verb.crossfade.'s internal clock
at the same time:
\begin{verbatim}
output.file(%vorbis,"record.ogg",crossfade(input.alsa()))
\end{verbatim}
The other possible error happens when unifying two unknown clock variables
if one depends on the other | in unification terminology, this is an occurs
check failure. A simple example of that situation is
the script \verb.add([s,crossfade(s)]). where the two mixed sources
respectively have clocks $c$ and $X_c$ where $c$ is the clock created
for the crossfading operator and $X_c$ is the variable representing
the clock to which the crossfading belongs, on which $c$ depends.

After this inference phase, it is possible that some clocks are still
unknown. Remaining variables are thus forcibly assigned to the default
wallclock, before that all new sources are prepared for streaming
by their respective clocks.
